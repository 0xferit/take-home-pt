# Portugal Tax Calculator - Design Principles

## Core Tenets

### 1. Precision
- **Zero tolerance for ambiguity**: Every calculation must be mathematically exact
- **Type safety**: Use explicit types, validate all inputs, sanitize all outputs
- **Single source of truth**: Constants defined once, referenced everywhere
- **Immutable data flows**: Pure functions with predictable outputs

### 2. Conciseness  
- **Attention is scarce**: Every word must earn its place
- **Progressive disclosure**: Essential information first, details collapsed
- **Remove redundancy**: If it can be inferred or linked, don't repeat it
- **Labels > explanations**: "Category B" not "Portuguese professional services income from self-employment activities"

### 3. Transparency
- **Show your work**: All calculations visible in Results → Calculation Steps
- **Verifiable sources**: Every claim links to official Portuguese government sources
- **Formula visibility**: Display actual math: `(BaseRate + Revenue × VariableRate) × Multiplier`
- **No black boxes**: If the calculator does it, the user can see it

### 4. Reproducibility
- **Methodology documentation**: Complete technical specs in Methodology tab
- **Source code as documentation**: Clean, commented, self-explanatory functions
- **Official sources only**: Diário da República, Portal das Finanças, INE, Segurança Social
- **Version controlled**: Every change tracked, rationale documented in commits

### 5. Separation of Concerns
- **Three-layer architecture**: Data, Logic, Presentation must be isolated
- **No cross-contamination**: UI changes cannot break calculations, regulation updates cannot affect styling
- **Team-safe**: Designers work on presentation, tax experts on data, developers on logic—independently
- **Regression-proof**: Changes in one layer are guaranteed not to affect others

## UI/UX Patterns

### Information Architecture
```
Input screens (Setup, Income, Expenses, Deductions):
  - Minimal help text
  - Essential labels only
  - Smart defaults that auto-calculate
  - Progressive disclosure for advanced options

Results screen:
  - Summary cards (what matters)
  - Detailed breakdown (show your work)
  - Calculation steps (full transparency)
  - Comparison table (side-by-side)

Methodology screen:
  - Complete technical documentation
  - Official source links for everything
  - Formula explanations
  - Legal references
```

### Help Text Guidelines
```
❌ BAD:  "Enter your 5-digit CAE (Economic Activity Classification) code to 
          automatically determine your activity type based on the official 
          Portuguese classification system maintained by INE."

✅ GOOD: "5-digit CAE code. Auto-determines activity type."
```

### Transparency Requirements
Every calculation must be:
1. **Inspectable**: Results → View calculation steps
2. **Sourced**: Link to official regulation/law
3. **Reproducible**: Formula shown in plain text
4. **Verifiable**: User can check against official tax tables

### Code Style
```javascript
// ✅ GOOD: Pure, testable, transparent
function computeProgressiveTax(income, brackets) {
  return brackets.reduce((total, bracket) => {
    const amount = Math.min(Math.max(0, income - bracket.min), 
                             bracket.max - bracket.min);
    return total + (amount * bracket.rate);
  }, 0);
}

// ❌ BAD: Side effects, opaque, stateful
let totalTax = 0;
function addTax(amount) {
  totalTax += calculateSomehow(amount); // What formula?
}
```

## Documentation Layers

### Layer 1: UI Labels (Scannable)
- What: "Annual Gross Income"
- Example: "€170,000"

### Layer 2: Help Text (Glanceable) 
- Context: "Category B professional services revenue"

### Layer 3: Methodology (Complete)
- Legal basis: "CIRS Article 31 - Activity Coefficients"
- Formula: `TaxableIncome = GrossIncome × Coefficient`
- Official source: [Link to Diário da República]
- Worked example with actual numbers

### Layer 4: Source Code (Authoritative)
- Implementation details
- Edge cases handled
- Unit test coverage
- Git history with rationale

## Quality Gates

Before shipping any feature, verify:
- [ ] Calculations are mathematically correct (unit tests pass)
- [ ] Every formula is visible in Results → Calculation Steps
- [ ] Every claim has an official source link
- [ ] Help text is concise (<10 words where possible)
- [ ] Advanced options are collapsed by default
- [ ] Methodology section documents the complete spec

## Anti-Patterns to Avoid

❌ **Verbose help text everywhere**
```html
<!-- BAD -->
<p class="help-text">
  This field is for entering your annual gross income from professional 
  services activities before deducting any expenses. This is also known 
  as Category B income in the Portuguese tax system...
</p>
```

❌ **Explaining why we do things in the UI**
```html
<!-- BAD -->
<p>We exclude investment income because it's taxed identically in both 
   structures at 28% flat rate so including it wouldn't affect the 
   comparison outcome...</p>
```

❌ **Hiding calculations**
```javascript
// BAD
const tax = calculateTax(income); // User has no idea how
```

❌ **Unsourced claims**
```html
<!-- BAD -->
<p>IRS Jovem provides a 100% exemption in Year 1</p>
<!-- No link to verify this claim -->
```

## Examples of Excellence

✅ **Concise label + transparent calculation**
```
Label: "Social Security"
Help:  "21.4% on 70% of gross (simplified)"
Results breakdown: 
  Relevant Income: €170,000 × 70% = €119,000
  Quarterly: €119,000 ÷ 4 = €29,750
  Monthly: €29,750 ÷ 3 = €9,917 (capped at €6,270)
  Contribution: €6,270 × 21.4% × 12 = €16,104/year
```

✅ **Smart defaults + optional override**
```
Business Expenses: €8,500 (auto: 5% of €170k)
[User can click to override]
```

✅ **Progressive disclosure**
```
Insurance: ~€850/year (0.50%)
  [Collapse] Override with actual quote
  [Collapse] Customize estimate (advanced)
```

## Architecture: Three-Layer Separation

### Layer 1: Regulatory Data (`data.js` / `regulations.js`)
**Pure data only. No logic, no presentation.**
```javascript
// ✅ GOOD: Pure regulatory constants
export const TAX_BRACKETS_2025 = [
  { min: 0, max: 8059, rate: 0.13 },
  { min: 8060, max: 12160, rate: 0.165 },
  // ...
];

export const SOCIAL_SECURITY_RATE = 0.214;
export const IAS_2025 = 522.50;

// ❌ BAD: Logic mixed with data
export function computeTax(income) { /* calculation here */ }
```

**Who touches this**: Tax accountants, legal team updating regulations  
**What changes here**: New tax year, law amendments, rate updates  
**Who doesn't touch**: Designers, frontend developers

### Layer 2: Business Logic (`logic.js`)
**Pure functions. No data definitions, no DOM.**
```javascript
// ✅ GOOD: Pure calculation function
export function computeProgressiveTax(income, brackets) {
  return brackets.reduce((total, bracket) => {
    const amount = Math.min(Math.max(0, income - bracket.min), 
                             bracket.max - bracket.min);
    return total + (amount * bracket.rate);
  }, 0);
}

// ❌ BAD: DOM manipulation in logic
function calculateAndDisplay(income) {
  const tax = compute(income);
  document.getElementById('result').textContent = tax; // NO!
}

// ❌ BAD: Data definition in logic file
const TAX_RATE = 0.214; // Should be in data.js
```

**Who touches this**: Developers implementing calculation algorithms  
**What changes here**: New features, calculation methods, formula improvements  
**Who doesn't touch**: Designers, content editors

### Layer 3: Presentation (`app.js`, `index.html`, `styles.css`)
**UI only. No calculations, no data.**
```javascript
// ✅ GOOD: Pure presentation logic
function updateDisplay(results) {
  setText('net-income', formatCurrency(results.netIncome));
  setText('tax-amount', formatCurrency(results.tax));
}

// ✅ GOOD: Event handling delegates to logic layer
incomeInput.addEventListener('input', (e) => {
  const results = computeSimplified({ // From logic.js
    grossIncome: parseFloat(e.target.value),
    // ...
  });
  updateDisplay(results);
});

// ❌ BAD: Calculation in presentation
incomeInput.addEventListener('input', (e) => {
  const tax = parseFloat(e.target.value) * 0.214; // NO!
  setText('tax', tax);
});
```

**Who touches this**: Designers, UX team, frontend developers  
**What changes here**: Styling, layout, accessibility, user interactions  
**Who doesn't touch**: Tax accountants, business logic developers

## File Structure

```
take-home-pt/
├── data.js              # Regulatory constants ONLY
│   ├── Tax brackets
│   ├── SS rates
│   ├── IAS values
│   ├── Activity codes
│   └── Deduction limits
│
├── logic.js             # Pure business logic ONLY
│   ├── computeProgressiveTax()
│   ├── computeSocialSecurity()
│   ├── computeSimplified()
│   └── computeTransparent()
│
├── app.js               # Presentation logic ONLY
│   ├── DOM manipulation
│   ├── Event handlers
│   ├── UI state management
│   └── Display formatters
│
├── index.html           # Structure ONLY
│   └── Semantic HTML, no inline logic
│
└── styles.css           # Styling ONLY
    └── Visual design, no business rules
```

## Isolation Guarantees

### ✅ Safe Operations (No Regression Risk)

| Who | Where | Can Change | Cannot Break |
|-----|-------|-----------|--------------|
| Designer | `index.html`, `styles.css`, `app.js` (display only) | Layout, colors, typography | Calculations, tax rates |
| Tax Expert | `data.js` | Rates, brackets, coefficients | UI, calculation logic |
| Developer | `logic.js` | Algorithms, formulas | Data values, UI styling |

### ❌ Dangerous Anti-Patterns

```javascript
// ❌ Data in presentation file (app.js)
const TAX_RATE = 0.214; // Belongs in data.js

// ❌ Logic in data file (data.js)
export function calculateTax(income) { /* ... */ } // Belongs in logic.js

// ❌ DOM in logic file (logic.js)
document.getElementById('result').textContent = tax; // Belongs in app.js

// ❌ Inline calculations in HTML
<p>Tax: €<span id="tax">${income * 0.214}</span></p> // Logic belongs in logic.js
```

## Testing Benefits

**With proper separation:**
- **Data tests**: Verify regulatory constants match official sources
- **Logic tests**: Unit test pure functions with known inputs/outputs
- **Presentation tests**: UI/accessibility testing without touching calculations

**Example: Logic unit test (isolated)**
```javascript
import { computeProgressiveTax } from './logic.js';
import { TAX_BRACKETS_2025 } from './data.js';

test('computes correct tax for €50k income', () => {
  expect(computeProgressiveTax(50000, TAX_BRACKETS_2025))
    .toBe(10567.50);
});
```

## Migration Strategy

When refactoring existing code:
1. **Extract data first**: Move all constants to `data.js`
2. **Purify logic**: Remove DOM manipulation from `logic.js`
3. **Thin presentation**: `app.js` becomes pure UI orchestration
4. **Verify isolation**: Each layer imports only from layers below
5. **Test independently**: Unit tests for logic, integration tests for presentation

## Version Management

### Date-Based Versioning with Automatic Commit Hash

**Version Format:** `YYYY.MM.DD.{commit_hash}`
- **YYYY.MM.DD** = Date of last code change (manual update in data.js)
- **{commit_hash}** = Automatic git commit short hash (auto-fetched at runtime)

**Example:** `2025.10.17.c432057` (changed on Oct 17, 2025, commit c432057)

**Key Advantage:** 🎯 **Simple and obvious** - version = date + commit hash

### Two-Tier Versioning System

#### Tier 1: Date Version (Manual, Every Change)
**Location:** `data.js` → `VERSION`  
**Format:** `YYYY.MM.DD`
**When to bump:** Every time you make a code change (any file)

**How to bump:**
```javascript
// In data.js - update to today's date:
VERSION: '2025.10.18',  // Change the date when you make changes
```

**Rule:** If you touch code today, version should be today's date.

**Frequency:** Every code change (use today's date)

#### Tier 2: Commit Hash (Automatic, Every Commit)
**Location:** Auto-fetched from GitHub API at runtime  
**Format:** 7-character git hash (e.g., `c432057`)
**When to bump:** Automatically with every commit  
**How to bump:** Just commit! Hash updates automatically

**Frequency:** Every single commit (no manual action)

### Displayed Version

Users see: **`TakeHome PT v2025.10.17.c432057`**

Breakdown:
- `2025.10.17` = Date version (manual, set in data.js)
- `c432057` = Commit hash (automatic, fetched from GitHub)

On hover: Shows commit date and message

### Why This Matters

1. **Audit Trail**: Every commit has a unique version - perfect traceability
2. **Bug Reports**: "Issue on v2025.2.a1b2c3d" maps to exact commit
3. **No Forgotten Bumps**: Build version updates automatically - impossible to forget
4. **Deployment Tracking**: Production version = exact commit hash
5. **Cache Busting**: Every commit gets new version, forces refresh
6. **Compliance**: Full version history, no gaps

### Git Commit Hash as Version

**Implementation:**
- `app.js` fetches latest commit from GitHub API
- Extracts short hash (first 7 characters)
- Displays as: `v{MAJOR}.{SHORT_HASH}`
- Falls back to major version only if API unavailable

**Benefits:**
- ✅ Automatic - no manual intervention
- ✅ Unique - every commit has unique version
- ✅ Traceable - version maps directly to commit
- ✅ Reliable - can't be forgotten or duplicated

### Developer Workflow

**Every Code Change:**
```bash
# 1. Update VERSION in data.js to today's date
# In data.js: VERSION: '2025.10.18'  (if today is Oct 18)

# 2. Commit and push
git commit -m "fix: correct tax calculation"
git push

# Version is now: 2025.10.18.{new_commit_hash}
```

**Multiple changes same day:**
```bash
# Date stays the same, only commit hash changes
# VERSION: '2025.10.18' (already set)
git commit -m "fix: another fix"
git push

# Version is now: 2025.10.18.{different_hash}
```

### Checklist Before Every Push

**CRITICAL - Always Required:**
- [ ] Updated `VERSION` in `data.js` to today's date (YYYY.MM.DD)?
- [ ] Version date matches actual date of change?

**Automatic (No Action Needed):**
- [x] Commit hash will auto-append to version

**Verification:**
- [ ] Test in browser with hard refresh
- [ ] Check footer shows: `v{today}.{hash}`

## Remember

**The UI teaches by doing, not by telling.**

Show the number. Show the formula. Link the source. Let users dig deeper if they want.
Attention is the scarcest resource. Respect it.

**Architecture is immutable trust.**

A designer changing CSS must never risk breaking tax calculations.
A tax expert updating rates must never risk breaking the UI.
Separation of concerns is separation of regression risk.

**Versions are accountability.**

Every change gets a version. Every version tells a story. Never push unversioned changes.
