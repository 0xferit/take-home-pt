# Portugal Tax Calculator - Design Principles

## Core Tenets

### 1. Precision
- **Zero tolerance for ambiguity**: Every calculation must be mathematically exact
- **Type safety**: Use explicit types, validate all inputs, sanitize all outputs
- **Single source of truth**: Constants defined once, referenced everywhere
- **Immutable data flows**: Pure functions with predictable outputs

### 2. Conciseness  
- **Attention is scarce**: Every word must earn its place
- **Progressive disclosure**: Essential information first, details collapsed
- **Remove redundancy**: If it can be inferred or linked, don't repeat it
- **Labels > explanations**: "Category B" not "Portuguese professional services income from self-employment activities"

### 3. Transparency
- **Show your work**: All calculations visible in Results → Calculation Steps
- **Verifiable sources**: Every claim links to official Portuguese government sources
- **Formula visibility**: Display actual math: `(BaseRate + Revenue × VariableRate) × Multiplier`
- **No black boxes**: If the calculator does it, the user can see it

### 4. Reproducibility
- **Methodology documentation**: Complete technical specs in Methodology tab
- **Source code as documentation**: Clean, commented, self-explanatory functions
- **Official sources only**: Diário da República, Portal das Finanças, INE, Segurança Social
- **Version controlled**: Every change tracked, rationale documented in commits

### 5. Separation of Concerns
- **Three-layer architecture**: Data, Logic, Presentation must be isolated
- **No cross-contamination**: UI changes cannot break calculations, regulation updates cannot affect styling
- **Team-safe**: Designers work on presentation, tax experts on data, developers on logic—independently
- **Regression-proof**: Changes in one layer are guaranteed not to affect others

## UI/UX Patterns

### Information Architecture
```
Input screens (Setup, Income, Expenses, Deductions):
  - Minimal help text
  - Essential labels only
  - Smart defaults that auto-calculate
  - Progressive disclosure for advanced options

Results screen:
  - Summary cards (what matters)
  - Detailed breakdown (show your work)
  - Calculation steps (full transparency)
  - Comparison table (side-by-side)

Methodology screen:
  - Complete technical documentation
  - Official source links for everything
  - Formula explanations
  - Legal references
```

### Help Text Guidelines
```
❌ BAD:  "Enter your 5-digit CAE (Economic Activity Classification) code to 
          automatically determine your activity type based on the official 
          Portuguese classification system maintained by INE."

✅ GOOD: "5-digit CAE code. Auto-determines activity type."
```

### Transparency Requirements
Every calculation must be:
1. **Inspectable**: Results → View calculation steps
2. **Sourced**: Link to official regulation/law
3. **Reproducible**: Formula shown in plain text
4. **Verifiable**: User can check against official tax tables

### Code Style
```javascript
// ✅ GOOD: Pure, testable, transparent
function computeProgressiveTax(income, brackets) {
  return brackets.reduce((total, bracket) => {
    const amount = Math.min(Math.max(0, income - bracket.min), 
                             bracket.max - bracket.min);
    return total + (amount * bracket.rate);
  }, 0);
}

// ❌ BAD: Side effects, opaque, stateful
let totalTax = 0;
function addTax(amount) {
  totalTax += calculateSomehow(amount); // What formula?
}
```

## Documentation Layers

### Layer 1: UI Labels (Scannable)
- What: "Annual Gross Income"
- Example: "€170,000"

### Layer 2: Help Text (Glanceable) 
- Context: "Category B professional services revenue"

### Layer 3: Methodology (Complete)
- Legal basis: "CIRS Article 31 - Activity Coefficients"
- Formula: `TaxableIncome = GrossIncome × Coefficient`
- Official source: [Link to Diário da República]
- Worked example with actual numbers

### Layer 4: Source Code (Authoritative)
- Implementation details
- Edge cases handled
- Unit test coverage
- Git history with rationale

## Quality Gates

Before shipping any feature, verify:
- [ ] Calculations are mathematically correct (unit tests pass)
- [ ] Every formula is visible in Results → Calculation Steps
- [ ] Every claim has an official source link
- [ ] Help text is concise (<10 words where possible)
- [ ] Advanced options are collapsed by default
- [ ] Methodology section documents the complete spec

## Anti-Patterns to Avoid

❌ **Verbose help text everywhere**
```html
<!-- BAD -->
<p class="help-text">
  This field is for entering your annual gross income from professional 
  services activities before deducting any expenses. This is also known 
  as Category B income in the Portuguese tax system...
</p>
```

❌ **Explaining why we do things in the UI**
```html
<!-- BAD -->
<p>We exclude investment income because it's taxed identically in both 
   structures at 28% flat rate so including it wouldn't affect the 
   comparison outcome...</p>
```

❌ **Hiding calculations**
```javascript
// BAD
const tax = calculateTax(income); // User has no idea how
```

❌ **Unsourced claims**
```html
<!-- BAD -->
<p>IRS Jovem provides a 100% exemption in Year 1</p>
<!-- No link to verify this claim -->
```

## Examples of Excellence

✅ **Concise label + transparent calculation**
```
Label: "Social Security"
Help:  "21.4% on 70% of gross (simplified)"
Results breakdown: 
  Relevant Income: €170,000 × 70% = €119,000
  Quarterly: €119,000 ÷ 4 = €29,750
  Monthly: €29,750 ÷ 3 = €9,917 (capped at €6,270)
  Contribution: €6,270 × 21.4% × 12 = €16,104/year
```

✅ **Smart defaults + optional override**
```
Business Expenses: €8,500 (auto: 5% of €170k)
[User can click to override]
```

✅ **Progressive disclosure**
```
Insurance: ~€850/year (0.50%)
  [Collapse] Override with actual quote
  [Collapse] Customize estimate (advanced)
```

## Architecture: Three-Layer Separation

### Layer 1: Regulatory Data (`data.js` / `regulations.js`)
**Pure data only. No logic, no presentation.**
```javascript
// ✅ GOOD: Pure regulatory constants
export const TAX_BRACKETS_2025 = [
  { min: 0, max: 8059, rate: 0.13 },
  { min: 8060, max: 12160, rate: 0.165 },
  // ...
];

export const SOCIAL_SECURITY_RATE = 0.214;
export const IAS_2025 = 522.50;

// ❌ BAD: Logic mixed with data
export function computeTax(income) { /* calculation here */ }
```

**Who touches this**: Tax accountants, legal team updating regulations  
**What changes here**: New tax year, law amendments, rate updates  
**Who doesn't touch**: Designers, frontend developers

### Layer 2: Business Logic (`logic.js`)
**Pure functions. No data definitions, no DOM.**
```javascript
// ✅ GOOD: Pure calculation function
export function computeProgressiveTax(income, brackets) {
  return brackets.reduce((total, bracket) => {
    const amount = Math.min(Math.max(0, income - bracket.min), 
                             bracket.max - bracket.min);
    return total + (amount * bracket.rate);
  }, 0);
}

// ❌ BAD: DOM manipulation in logic
function calculateAndDisplay(income) {
  const tax = compute(income);
  document.getElementById('result').textContent = tax; // NO!
}

// ❌ BAD: Data definition in logic file
const TAX_RATE = 0.214; // Should be in data.js
```

**Who touches this**: Developers implementing calculation algorithms  
**What changes here**: New features, calculation methods, formula improvements  
**Who doesn't touch**: Designers, content editors

### Layer 3: Presentation (`app.js`, `index.html`, `styles.css`)
**UI only. No calculations, no data.**
```javascript
// ✅ GOOD: Pure presentation logic
function updateDisplay(results) {
  setText('net-income', formatCurrency(results.netIncome));
  setText('tax-amount', formatCurrency(results.tax));
}

// ✅ GOOD: Event handling delegates to logic layer
incomeInput.addEventListener('input', (e) => {
  const results = computeSimplified({ // From logic.js
    grossIncome: parseFloat(e.target.value),
    // ...
  });
  updateDisplay(results);
});

// ❌ BAD: Calculation in presentation
incomeInput.addEventListener('input', (e) => {
  const tax = parseFloat(e.target.value) * 0.214; // NO!
  setText('tax', tax);
});
```

**Who touches this**: Designers, UX team, frontend developers  
**What changes here**: Styling, layout, accessibility, user interactions  
**Who doesn't touch**: Tax accountants, business logic developers

## File Structure

```
take-home-pt/
├── data.js              # Regulatory constants ONLY
│   ├── Tax brackets
│   ├── SS rates
│   ├── IAS values
│   ├── Activity codes
│   └── Deduction limits
│
├── logic.js             # Pure business logic ONLY
│   ├── computeProgressiveTax()
│   ├── computeSocialSecurity()
│   ├── computeSimplified()
│   └── computeTransparent()
│
├── app.js               # Presentation logic ONLY
│   ├── DOM manipulation
│   ├── Event handlers
│   ├── UI state management
│   └── Display formatters
│
├── index.html           # Structure ONLY
│   └── Semantic HTML, no inline logic
│
└── styles.css           # Styling ONLY
    └── Visual design, no business rules
```

## Isolation Guarantees

### ✅ Safe Operations (No Regression Risk)

| Who | Where | Can Change | Cannot Break |
|-----|-------|-----------|--------------|
| Designer | `index.html`, `styles.css`, `app.js` (display only) | Layout, colors, typography | Calculations, tax rates |
| Tax Expert | `data.js` | Rates, brackets, coefficients | UI, calculation logic |
| Developer | `logic.js` | Algorithms, formulas | Data values, UI styling |

### ❌ Dangerous Anti-Patterns

```javascript
// ❌ Data in presentation file (app.js)
const TAX_RATE = 0.214; // Belongs in data.js

// ❌ Logic in data file (data.js)
export function calculateTax(income) { /* ... */ } // Belongs in logic.js

// ❌ DOM in logic file (logic.js)
document.getElementById('result').textContent = tax; // Belongs in app.js

// ❌ Inline calculations in HTML
<p>Tax: €<span id="tax">${income * 0.214}</span></p> // Logic belongs in logic.js
```

## Testing Benefits

**With proper separation:**
- **Data tests**: Verify regulatory constants match official sources
- **Logic tests**: Unit test pure functions with known inputs/outputs
- **Presentation tests**: UI/accessibility testing without touching calculations

**Example: Logic unit test (isolated)**
```javascript
import { computeProgressiveTax } from './logic.js';
import { TAX_BRACKETS_2025 } from './data.js';

test('computes correct tax for €50k income', () => {
  expect(computeProgressiveTax(50000, TAX_BRACKETS_2025))
    .toBe(10567.50);
});
```

## Migration Strategy

When refactoring existing code:
1. **Extract data first**: Move all constants to `data.js`
2. **Purify logic**: Remove DOM manipulation from `logic.js`
3. **Thin presentation**: `app.js` becomes pure UI orchestration
4. **Verify isolation**: Each layer imports only from layers below
5. **Test independently**: Unit tests for logic, integration tests for presentation

## Version Management

### CRITICAL: Always Bump Version After Changes

**RULE:** Any change to code, data, or logic MUST bump the version number.

**Version Format:** `YYYY.X` (e.g., `2025.1`, `2025.2`, `2025.3`)
- **YYYY** = Current year
- **X** = Sequential increment starting from 1 each year

**Location:** `data.js` → `VERSION` and `LAST_UPDATED`

### When to Bump

✅ **Always bump for:**
- Bug fixes (any severity)
- Feature additions
- Data updates (tax rates, regulations)
- Logic changes (calculations, formulas)
- UI changes (layout, styling, text)
- Documentation updates (if user-facing)

❌ **Don't bump for:**
- Internal comments only
- Development/testing files
- README/internal docs (non-user-facing)

### How to Bump

```javascript
// In data.js, update both fields:
VERSION: '2025.3',           // Increment the number
LAST_UPDATED: '2025-10-17',  // Update the date
```

**Commit Message:** Include version in commit message
```bash
# Good examples:
git commit -m "fix(critical): correct property names (v2025.2)"
git commit -m "feat(multi-year): add 10-year projection (v2025.2)"
git commit -m "chore: bump version to 2025.3"
```

### Why This Matters

1. **Audit Trail**: Users can see exactly which version they're using
2. **Bug Reports**: "I found an issue on v2025.2" is actionable
3. **Deployment Tracking**: Netlify/production version matches code
4. **Cache Busting**: Version change forces browser refresh
5. **Compliance**: Regulatory tools require version tracking

### Checklist Before Every Push

- [ ] Code/data changes made?
- [ ] Version bumped in `data.js`?
- [ ] `LAST_UPDATED` set to today?
- [ ] Version mentioned in commit message?
- [ ] Tested in browser with hard refresh?

## Remember

**The UI teaches by doing, not by telling.**

Show the number. Show the formula. Link the source. Let users dig deeper if they want.
Attention is the scarcest resource. Respect it.

**Architecture is immutable trust.**

A designer changing CSS must never risk breaking tax calculations.
A tax expert updating rates must never risk breaking the UI.
Separation of concerns is separation of regression risk.

**Versions are accountability.**

Every change gets a version. Every version tells a story. Never push unversioned changes.
